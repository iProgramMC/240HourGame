#include "World.hpp"

const char* g_defaultWorld =
    "...#...................................................................................................................................................................................................."
    "...##########################..........................................................................................................................................................................."
    "............................#..........................................................................................................................................................................."
    "#####.......................#..........................................................................................................................................................................."
    "....#........____#___.......#..........................................................................................................................................................................."
    "....#......_#...............#..........................................................................................................................................................................."
    "....#...._#............___..#..........................................................................................................................................................................."
    "....#.._#.......___.........#..........................................................................................................................................................................."
    "....#######################.#..........................................................................................................................................................................."
    "........................................................................................................................................................................................................"
    "#################################....###################################################################################################################################################################"
    "#################################....###################################################################################################################################################################"
    //"........................................................................................................................................................................................................"
    //"........................................................................................................................................................................................................"
    //"........................................................................................................................................................................................................"
    ;

World* g_world = nullptr;
World* GetWorld()
{
    if (g_world == nullptr)
        g_world = new World();

    return g_world;
}

int CharToTileID(char tile)
{
    switch (tile)
    {
    case '.': return 0;
    case '#': return 1;
    case '?': return 2;
    case 'U': return 3;
    case '_': return 4;
    }
    return 0;
}

World::World()
{
    m_worldWidth = C_WORLDWIDTH;
    m_worldHeight = C_WORLDHEIGHT;

    // initialize our world
    m_tiles = new Tile[m_worldWidth * m_worldHeight];
    for (int i = 0; i < m_worldWidth * m_worldHeight; i++)
    {
        m_tiles[i].m_ID = CharToTileID (g_defaultWorld[i]);
        m_tiles[i].m_x = i % m_worldWidth;
        m_tiles[i].m_y = i / m_worldWidth;
    }
}

World::~World()
{
    delete[] m_tiles;
}

Tile* World::GetTile(int x, int y)
{
    if (x<0||y<0||x>=m_worldWidth||y>=m_worldHeight)return nullptr;
    return &m_tiles[x + y * m_worldWidth];
}

void World::AddTilesInRect (Rect rect, std::vector<Tile*>& output)
{
    int x = rect.x, y = rect.y, x2 = rect.x + rect.w, y2 = rect.y + rect.h;

    int le = x/32, re = x2 / 32;
    int te = y/32, be = y2 / 32;
    for (int i = le; i <= re; i++)
    {
        for (int j = te; j <= be; j++)
        {
            // add the tile to the vector
            if (GetTile(i, j) != nullptr)
            {
                output.push_back (GetTile(i, j));
            }
        }
    }
}

int World::GetVisual (int x, int y) {
    if (GetTile(x, y) == nullptr) return -1;

    switch (GetTile(x, y)->m_ID) {
    case 1: return VISUAL_XY_TO_INDEX(8, 1);
    case 2: return VISUAL_XY_TO_INDEX(8, 2);
    case 3: return VISUAL_XY_TO_INDEX(9, 2);
    case 4: return VISUAL_XY_TO_INDEX(6, 3);
    }
    return -1;
}

int World::IsTileCollidable (int x, int y) {
    if (GetTile(x, y) == nullptr) return true;

    int id = GetTile(x, y)->m_ID;
    if (id == 4) return 2;
    return id != 0;//! TODO
}
void World::ClearVectorAndAddCollidableTilesInRect (Rect rect, std::vector<Tile*>& output)
{
    output.clear();
    int x = rect.x, y = rect.y, x2 = rect.x + rect.w-1, y2 = rect.y + rect.h-1;

    int le = x/32, re = x2 / 32;
    int te = y/32, be = y2 / 32;
    for (int i = le; i <= re; i++)
    {
        for (int j = te; j <= be; j++)
        {
            // add the tile to the vector
            if (GetTile(i, j) != nullptr)
            {
                if (IsTileCollidable(i, j))
                    output.push_back (GetTile(i, j));
            }
        }
    }
}
